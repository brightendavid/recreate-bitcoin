# 文件分析
* UTXO.txt :记录UTXO，以硬件形式记录，每隔5分钟记录更新一次

# 交易的传播
* 对于每个节点，使用多个固定的IP作为活跃节点，发送区块到这些节点作为交易的传播
* 受到区块，进行节点的更新（不进行验证）
* 受到交易（单个区块），进行独立的验证（UTXO 和 交易缓冲池 和 数据有效性验证）


## 每个节点存储的信息
BTC网络并不是收到一条广播就立刻更新系统的状态，而是有区块以及内存池的设计。

网络中的（全功能）节点各自维护一个状态的副本，并在某一时刻就系统的状态达成最终一致。

在某一个时刻，所有BTC节点都维护着一个记录UTXO的账本，并有一个接收未确认交易的内存池（Mempool）

只需要将新增的交易记录发送给对方节点就够了。对方节点只需要将这条交易记录补充到自己的账本即可

将每次收到的新增交易第一时间放入交易内存池中，而不是写入账本。等内存池中的交易积累了一段时间（例如每隔10分钟），再一次性的写入到账本中

* UTXO（存在硬盘中，文件） UTXO还是交易16进制字符串
* Menmpool（存在内存中，每隔一段时间进行验证-》清空-》更新UTXO）
* 区块

收到boardcost->立刻更新到Menpool->验证boardcost的交易有效性->更新自己的UTXO

# 基本流程
* 1,交易产生(交易：16进制的字符)
* 2,交易的广播(加入Menmpool->经过一段时间->写入UTXO)


# server 端 和 client 端 作用分析
* 对于每个节点，都有一个server和一个client部分，server接收其他节点的交易,client发送本节点的交易

## server port 分析
* 接收所有区块，缺失的区块进行有效性分析，写入chain
* 接受的ip地址只有固定的多个Ip
* 还是定时更新，不能实时更新
* 重复性判定：是否是本机的已有区块，是接收之后的第一个判定


# UTXO 
* 所有的机器都有某笔旧交易存在UTXO中
* UXTO 是每个特定交易 的每个输出  里面是  公钥和金额  直接连接，没有其他东西
* UTXO 是不可分离的
* 每有一笔交易进入，减去输入，加上输出

# 本机更新完毕之后
* 发送新的区块到特定的活跃节点（发过的区块不再发送）
* 收到别的交易，判定缺失，缺失的交易写入tx_block.txt


## UTXO anb tx_block chain 区别分析
* 更新 __block chain__ 就是更新 __UTXO__

# 验证签名
* message 全部是16进制不变
* sk,pk,message有存储形式和使用形式,为16进制和2进



# 加入区块链概念之后
* 保存形式为区块block,含有一个header和多个transactions
* 每个block 通过hash 互相串联，保存在block 的header中
## tranaction 之间呈现树形关系，同为树的叶节点
## header包括的信息
* previous block hash
* time
* nonce (需要计算)，pow中使用
* difficulty,与pow 有关，保证每隔10分钟产生一个区块的速度
* tranactions hash，为transactions 产生的二叉树的根节点的hash
* 若是transaction 已经使用过，则保存为hash(transaction)

# 由一个很大的问题
* 交易如何分割为区块
* 区块中的交易如何排序（按照字母表顺序）
## 交易的产生步骤
* 交易->menmpool->UTXO 消除->save into block->boardcost __new__ blocks
# tx_block0.txt 为创世区块
* block产生 之后 不能够改变

# 存储了两倍的数据
* 所有交易(不分块)
* 区块链(分块) 